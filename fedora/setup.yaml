---
# Ansible playbook for Fedora development machine setup
# Manages DNF packages, Flatpak packages, PowerShell modules, pipx modules, VS Code extensions, and Git configuration

- name: Setup development environment on Fedora
  hosts: localhost
  connection: local
  gather_facts: yes
  # Define the become password at the play level so it's available to all tasks
  vars:
    ansible_become_pass: "{{ lookup('env', 'ANSIBLE_SUDO_PASS') }}"
    ansible_connection: local

  vars_files:
    - vars.yaml

  tasks:
    # System setup
    - name: Check WSL version (0=not WSL, 1=WSL1, 2=WSL2)
      ansible.builtin.shell: |
        if ! grep -q -i microsoft /proc/version && ! uname -r | grep -q microsoft; then
          exit 0
        fi

        if grep -q -i "microsoft.*wsl2" /proc/version || uname -r | grep -q "microsoft.*wsl2"; then
          exit 2
        elif [ -f /proc/sys/kernel/osrelease ] && grep -q "microsoft" /proc/sys/kernel/osrelease; then
          exit 1
        elif grep -q -i microsoft /proc/version || uname -r | grep -q microsoft; then
          exit 1
        else
          exit 0
        fi
      register: wsl_check
      ignore_errors: yes
      changed_when: false
      tags:
        - system
        - wsl

    # Set WSL facts based on the WSL check result
    - name: Set WSL facts
      ansible.builtin.set_fact:
        is_wsl: "{{ wsl_check.rc != 0 }}"
        wsl_version: "{{ wsl_check.rc }}"
        is_wsl1: "{{ wsl_check.rc == 1 }}"
        is_wsl2: "{{ wsl_check.rc == 2 }}"
      tags:
        - system
        - wsl

    # Get RPM architecture directly from ansible_architecture
    - name: Set RPM architecture fact
      ansible.builtin.set_fact:
        rpm_architecture: "{{ ansible_architecture }}"
      tags:
        - system
        - architecture

    # Display detected architecture
    - name: Display detected architecture
      ansible.builtin.debug:
        msg:
          - "Detected system architecture: {{ ansible_architecture }}"
          - "Using RPM architecture: {{ rpm_architecture }}"
      tags:
        - system
        - architecture

    # dnf makecache
    - name: Update DNF cache
      ansible.builtin.dnf:
        update_cache: yes
      become: yes
      tags:
        - dnf
        - update

    # dnf upgrade
    - name: Upgrade all packages # noqa: package-latest
      ansible.builtin.dnf:
        name: '*'
        state: latest
      become: yes
      tags:
        - dnf
        - upgrade

    # Install prerequisite DNF packages
    - name: Install prerequisite DNF packages
      ansible.builtin.dnf:
        name: "{{ dnf_packages_prereqs | selectattr('supported_architectures', 'undefined') | map(attribute='name') | list + dnf_packages_prereqs | selectattr('supported_architectures', 'defined') | selectattr('supported_architectures', 'contains', rpm_architecture) | map(attribute='name') | list }}"
        state: present
      become: yes
      tags:
        - dnf
        - prereqs
        - packages

    # Add external DNF repositories
    - name: Add external DNF repositories
      ansible.builtin.yum_repository:
        name: "{{ item.name }}"
        description: "{{ item.description | default(item.name) }}"
        baseurl: "{{ item.baseurl }}"
        gpgkey: "{{ item.gpgkey | default(omit) }}"
        gpgcheck: "{{ item.gpgcheck | default(true) }}"
        enabled: true
        state: present
      loop: "{{ external_dnf_repositories }}"
      loop_control:
        label: "Adding repository: {{ item.name }}"
      when: item.supported_architectures is not defined or rpm_architecture in item.supported_architectures
      become: yes
      tags:
        - dnf
        - repositories

    # Install DNF packages
    - name: Install DNF packages
      ansible.builtin.dnf:
        name: "{{ dnf_packages | selectattr('supported_architectures', 'undefined') | map(attribute='name') | list + dnf_packages | selectattr('supported_architectures', 'defined') | selectattr('supported_architectures', 'contains', rpm_architecture) | map(attribute='name') | list }}"
        state: present
      become: yes
      tags:
        - dnf
        - packages

    # Flatpak setup
    - name: Ensure Flatpak is installed
      ansible.builtin.dnf:
        name: flatpak
        state: present
      become: yes
      when: flatpak_packages | length > 0
      tags:
        - flatpak
        - packages

    - name: Add Flathub remote
      community.general.flatpak_remote:
        name: flathub
        flatpakrepo_url: https://dl.flathub.org/repo/flathub.flatpakrepo
        state: present
      become: yes
      when: flatpak_packages | length > 0
      tags:
        - flatpak
        - packages

    - name: Install Flatpak packages
      community.general.flatpak:
        name: "{{ item.name }}"
        state: present
        remote: flathub
      become: yes
      loop: "{{ flatpak_packages }}"
      when: item.supported_architectures is not defined or rpm_architecture in item.supported_architectures
      register: flatpak_install_result
      failed_when: false
      loop_control:
        label: "Installing Flatpak: {{ item.name }}"
      tags:
        - flatpak
        - packages

    # npm configuration and installation
    - name: Configure npm to use user directory for global packages
      ansible.builtin.shell: |
        mkdir -p ~/.local
        npm config set prefix ~/.local
      args:
        creates: ~/.local/lib/node_modules
      when: npm_global_packages | length > 0
      tags:
        - npm
        - packages

    # npm global package checks
    - name: Check if npm packages are already installed
      ansible.builtin.shell: |
        export PATH=~/.local/bin:$PATH
        npm list -g {{ item }}
      register: npm_check_result
      changed_when: false
      failed_when: false
      loop: "{{ npm_global_packages | default([]) }}"
      loop_control:
        label: "Checking npm package: {{ item }}"
      tags:
        - npm
        - packages

    # npm global package installs
    - name: Ensure npm global packages are installed
      ansible.builtin.shell: |
        export PATH=~/.local/bin:$PATH
        npm install -g {{ item.0 }}
      loop: "{{ npm_global_packages | default([]) | zip(npm_check_result.results) | list }}"
      when: "item.1.rc != 0"
      register: npm_install_result
      changed_when: "npm_install_result.rc == 0"
      loop_control:
        label: "Installing npm package: {{ item.0 }}"
      tags:
        - npm
        - packages

    # .NET Install check
    - name: Check if dotnet is installed
      ansible.builtin.command:
        cmd: dotnet --version
      register: dotnet_check
      changed_when: false
      failed_when: false
      tags:
        - dotnet
        - tools

    # .NET global tools install check
    - name: Check if .NET global tools are already installed
      ansible.builtin.command:
        cmd: dotnet tool list -g
      register: dotnet_tools_list
      changed_when: false
      failed_when: false
      when: dotnet_check.rc == 0
      tags:
        - dotnet
        - tools

    # Install .NET global tools
    - name: Ensure .NET global tools are installed
      ansible.builtin.command:
        cmd: dotnet tool install -g {{ item }}
      loop: "{{ dotnet_tools | default([]) }}"
      register: dotnet_tool_install_result
      changed_when: "'already installed' not in dotnet_tool_install_result.stderr and dotnet_tool_install_result.rc == 0"
      failed_when: false
      when:
        - dotnet_check.rc == 0
        - item not in dotnet_tools_list.stdout
      loop_control:
        label: "Installing .NET tool: {{ item }}"
      tags:
        - dotnet
        - tools

    # Add .NET global tools to PATH
    - name: Add .NET global tools to PATH
      ansible.builtin.lineinfile:
        path: ~/.bashrc
        line: 'export PATH="$HOME/.dotnet/tools:$PATH"'
        state: present
      when: dotnet_check.rc == 0
      tags:
        - dotnet
        - tools
        - path

    # PowerShell installation check
    - name: Check if PowerShell is installed
      ansible.builtin.command:
        cmd: pwsh --version
      environment:
        PATH: "{{ ansible_env.HOME }}/.dotnet/tools:{{ ansible_env.PATH }}"
      register: pwsh_check
      changed_when: false
      failed_when: false
      tags:
        - powershell
        - modules

    # PowerShell modules
    - name: Install PowerShell modules
      ansible.builtin.command:
        cmd: pwsh -Command "Install-PSResource -Name {{ item }} -TrustRepository"
      environment:
        PATH: "{{ ansible_env.HOME }}/.dotnet/tools:{{ ansible_env.PATH }}"
      loop: "{{ powershell_modules }}"
      register: pwsh_install_result
      changed_when: "'is already installed' not in pwsh_install_result.stdout"
      loop_control:
        label: "Installing PowerShell module: {{ item }}"
      when: pwsh_check.rc == 0
      tags:
        - powershell
        - modules

    # Install pipx modules
    - name: Install pipx modules
      ansible.builtin.shell: |
        pipx install {{ item }}
      loop: "{{ pipx_packages }}"
      register: pipx_install_result
      changed_when: "'already installed' not in pipx_install_result.stdout"
      loop_control:
        label: "Installing pipx module: {{ item }}"
      tags:
        - pipx
        - modules

    # VS Code extension setup
    - name: Ensure VS Code extensions are installed
      ansible.builtin.command:
        cmd: code --install-extension {{ item }}
      loop: "{{ vscode_extensions }}"
      register: vscode_ext_result
      changed_when: "'already installed' not in vscode_ext_result.stdout"
      loop_control:
        label: "Installing VS Code extension: {{ item }}"
      tags:
        - vscode
        - extensions

    # AppImage setup
    - name: Ensure AppImage install directory exists
      ansible.builtin.file:
        path: "{{ appimage_install_dir }}"
        state: directory
        mode: '0755'
      when: appimage_packages is defined and appimage_packages | length > 0
      tags:
        - appimage

    - name: Ensure desktop entry directory exists
      ansible.builtin.file:
        path: "{{ ansible_env.HOME }}/.local/share/applications"
        state: directory
        mode: '0755'
      when: appimage_packages is defined and appimage_packages | length > 0
      tags:
        - appimage

    - name: Check if AppImage already exists
      ansible.builtin.stat:
        path: "{{ appimage_install_dir }}/{{ item.name }}.AppImage"
      register: appimage_stat
      loop: "{{ appimage_packages | default([]) }}"
      when: item.supported_architectures is not defined or rpm_architecture in item.supported_architectures
      loop_control:
        label: "Checking AppImage: {{ item.name }}"
      tags:
        - appimage

    - name: Download AppImage
      ansible.builtin.get_url:
        url: "{{ item.0.url }}"
        dest: "{{ appimage_install_dir }}/{{ item.0.name }}.AppImage"
        mode: '0755'
        checksum: "{{ item.0.checksum | default(omit) }}"
      loop: "{{ appimage_packages | default([]) | zip(appimage_stat.results | default([])) | list }}"
      when:
        - item.1.stat is defined
        - not item.1.stat.exists
      loop_control:
        label: "Downloading AppImage: {{ item.0.name }}"
      tags:
        - appimage

    - name: Create AppImage desktop entry
      ansible.builtin.copy:
        dest: "{{ ansible_env.HOME }}/.local/share/applications/{{ item.name }}.desktop"
        content: |
          [Desktop Entry]
          Name={{ item.name | capitalize }}
          Exec={{ appimage_install_dir }}/{{ item.name }}.AppImage{{ ' --no-sandbox' if (item.no_sandbox | default(false)) else '' }} %F
          Terminal=false
          Type=Application
          Icon={{ item.name }}
          StartupWMClass={{ item.name | capitalize }}
          Comment={{ item.comment | default(item.name) }}
          MimeType={{ item.mime_types | default('') }}
          Categories={{ item.categories | default('Application;') }}
        mode: '0644'
      loop: "{{ appimage_packages | default([]) }}"
      when: item.supported_architectures is not defined or rpm_architecture in item.supported_architectures
      loop_control:
        label: "Creating desktop entry: {{ item.name }}"
      tags:
        - appimage

    - name: Create AppImage CLI symlink
      ansible.builtin.file:
        src: "{{ appimage_install_dir }}/{{ item.name }}.AppImage"
        dest: "{{ appimage_install_dir }}/{{ item.name }}"
        state: link
        force: true
      loop: "{{ appimage_packages | default([]) }}"
      when: item.supported_architectures is not defined or rpm_architecture in item.supported_architectures
      loop_control:
        label: "Creating symlink: {{ item.name }}"
      tags:
        - appimage

    # Cursor extension setup
    - name: Check if Cursor CLI is available
      ansible.builtin.command:
        cmd: which cursor
      environment:
        PATH: "{{ appimage_install_dir }}:{{ ansible_env.PATH }}"
      register: cursor_cli_check
      changed_when: false
      failed_when: false
      when: appimage_install_dir is defined
      tags:
        - cursor
        - extensions

    - name: Ensure Cursor extensions are installed
      ansible.builtin.command:
        cmd: cursor --install-extension {{ item }}
      environment:
        PATH: "{{ appimage_install_dir }}:{{ ansible_env.PATH }}"
      ignore_errors: yes
      loop: "{{ vscode_extensions }}"
      register: cursor_ext_result
      changed_when: "'already installed' not in cursor_ext_result.stdout"
      when:
        - appimage_install_dir is defined
        - cursor_cli_check.rc == 0
      loop_control:
        label: "Installing Cursor extension: {{ item }}"
      tags:
        - cursor
        - extensions

    # Git LFS setup
    - name: Ensure Git LFS is initialized
      ansible.builtin.command:
        cmd: git lfs install
      register: git_lfs_result
      changed_when: "'Already initialized' not in git_lfs_result.stdout"
      tags:
        - git
        - lfs

    # Git configuration (user.name)
    - name: Configure Git user.name
      ansible.builtin.command:
        cmd: git config --global user.name "{{ git_user_name }}"
      register: git_name_result
      changed_when: git_name_result.rc == 0
      when: git_user_name is defined and git_user_name != ""
      tags:
        - git
        - config

    # Git configuration (user.email)
    - name: Configure Git user.email
      ansible.builtin.command:
        cmd: git config --global user.email "{{ git_user_email }}"
      register: git_email_result
      changed_when: git_email_result.rc == 0
      when: git_user_email is defined and git_user_email != ""
      tags:
        - git
        - config

    # Custom user commands
    - name: Execute custom user commands
      ansible.builtin.shell: "{{ item.command }}"
      loop: "{{ custom_commands_user }}"
      loop_control:
        label: "Executing: {{ item.description }}"
      tags:
        - custom
        - user-commands

    # Custom elevated commands
    - name: Execute custom elevated commands
      ansible.builtin.shell: "{{ item.command }}"
      become: yes
      loop: "{{ custom_commands_elevated }}"
      loop_control:
        label: "Executing: {{ item.description }}"
      tags:
        - custom
        - elevated-commands

    # Check if custom script is defined and exists
    - name: Check if custom script exists
      ansible.builtin.stat:
        path: "{{ custom_script }}"
      register: custom_script_stat
      when: custom_script is defined and custom_script != ""
      tags:
        - custom
        - script

    # Make custom script executable
    - name: Make custom script executable
      ansible.builtin.file:
        path: "{{ custom_script }}"
        mode: '0755'
      when: custom_script is defined and custom_script != "" and custom_script_stat.stat.exists
      tags:
        - custom
        - script

    # Execute custom script
    - name: Execute custom script
      ansible.builtin.command:
        cmd: "{{ custom_script }}"
      when: custom_script is defined and custom_script != "" and custom_script_stat.stat.exists
      tags:
        - custom
        - script

    # Notify user of completion
    - name: Setup complete
      ansible.builtin.debug:
        msg: "Fedora development environment setup complete!"
      tags:
        - always
